<!DOCTYPE html>
<html>
<head>
    <title>Visualisation 3D - Nappe Phreatique</title>
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: black; /* violet-noir */
            color: #fff;
        }
        #cursor {
            pointer-events: none;
            user-select: none;
        }
        #scatterChartContainer {
            width: 80vw;
            height: 80vh;
            margin: auto;
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 0 40px #000;
            background: #1a1026; /* violet-noir */
            display: none;
            align-items: stretch;
            justify-content: stretch;
        }
        #scatterChart {
            width: 100% !important;
            height: 100% !important;
            display: block;
            background: #1a1026 !important;
        }
        /* Style boutons overlay */
        #mapMenuOverlay button {
            background: #2d1846;
            color: #fff;
            border: none;
            border-radius: 6px;
            transition: background 0.2s;
        }
        #mapMenuOverlay button:hover {
            background: #5e35b1;
        }
        /* Style popup leaflet */
        .leaflet-popup-content-wrapper, .leaflet-popup-tip {
            background: #2d1846 !important;
            color: #fff !important;
        }
        .leaflet-popup-content button {
            background: #e53935;
            color: #fff;
            border: none;
            border-radius: 6px;
            margin-top: 8px;
            padding: 6px 14px;
            font-size: 1em;
            cursor: pointer;
        }
        .leaflet-popup-content button:hover {
            background: #ff1744;
        }
        /* Overlay */
        #mapMenuOverlay {
            background: #1a1026 !important;
        }
        /* Carte leaflet */
        #leafletMapContainer {
            background: #1a1026;
        }
    </style>
</head>
<body>
    <a-scene physics="debug: false; gravity: 0">
        <!-- Mur -->
        <a-entity id="mur">
            <!-- Mur 1 (Face avant) -->
            <a-plane position="0 2.355 -5.2" rotation="0 0 0" width="6.93" height="4.75" shadow="cast:true; receive:true" static-body
            material="src: ./textures/texture-mur.jpg; roughness: 1; metalness: 0; repeat: 3 1;"></a-plane>
            
            <!-- Mur 2 (Avant-droite) -->
            <a-plane position="4.5 2.355 -2.6" rotation="0 -60 0" width="6.93" height="4.75" shadow="cast:true; receive:true" static-body
            material="src: ./textures/texture-mur.jpg; roughness: 1; metalness: 0; repeat: 3 1;"></a-plane>
            
            <!-- Mur 3 (Arriere-droite) -->
            <a-plane position="4.5 2.355 2.6" rotation="0 -120 0" width="6.93" height="4.75" shadow="cast:true; receive:true" static-body
            material="src: ./textures/texture-mur.jpg; roughness: 1; metalness: 0; repeat: 3 1;"></a-plane>
            
            <!-- Mur 4 (Face arriere) -->
            <a-plane position="0 2.355 5.2" rotation="0 180 0" width="6.93" height="4.75" shadow="cast:true; receive:true" static-body
            material="src: ./textures/texture-mur.jpg; roughness: 1; metalness: 0; repeat: 3 1;"></a-plane>
            
            <!-- Mur 5 (Arriere-gauche) -->
            <a-plane position="-4.5 2.355 2.6" rotation="0 120 0" width="6.93" height="4.75" shadow="cast:true; receive:true" static-body
            material="src: ./textures/texture-mur.jpg; roughness: 1; metalness: 0; repeat: 3 1;"></a-plane>
            
            <!-- Mur 6 (Avant-gauche) -->
            <a-plane position="-4.5 2.355 -2.6" rotation="0 60 0" width="6.93" height="4.75" shadow="cast:true; receive:true" static-body
            material="src: ./textures/texture-mur.jpg; roughness: 1; metalness: 0; repeat: 3 1;"></a-plane>
        </a-entity>
        
        <!-- Porte arri√®re -->
        <a-plane id="backDoor" position="0 2.1 -5.1" rotation="0 0 0" width="2" height="4" color="#14532d" class="interactive"></a-plane>
        <!-- Porte avant -->
        <a-plane id="frontRightDoor" position="0 2.1 5.1" rotation="0 180 0" width="2" height="4" color="#1976d2" class="interactive"></a-plane>


        <!-- Plafond -->
        <a-entity id="plafond">
            <a-circle position="0 4.75 0" rotation="90 0 0" radius="7" static-body
                material="src: ./textures/metal_black1k.jpg; color: #696969; roughness: 1; metalness: 0; repeat: 3 3; emissive: #000000; emissiveIntensity: 3;">
            </a-circle>
            <a-entity id="lumNappesToit" light="type: spot; color: #FFFFFF; intensity: 0.9; castShadow: true; angle: 35; penumbra: 0.7" position="0 4.7 0" rotation="-90 0 0"></a-entity>
            <a-entity id="lumNappesSol" light="type: spot; color: #FFFFFF; intensity: 0.9; castShadow: true; angle: 35; penumbra: 0.7" position="0 -0.125 0" rotation="90 0 0"></a-entity>
        </a-entity>

        <!-- Sol -->
        <a-circle id="sol" position="0 0 0" radius="7" rotation="-90 0 0" static-body
            material="src: ./textures/test-sol.jpg; color: #696969; roughness: 1; metalness: 0; repeat: 8 8;" segments-radial="6">
        </a-circle>

        <!-- Plinthes bas -->
        <a-entity id="plinthes-Bas">
            <!-- Face avant -->
            <a-box position="0 0 -5.2" rotation="0 0 0" width="6.93" height="0.02" depth="0.1" static-body
            material="color: white; emissive: #0035ff ; emissiveIntensity: 0.6"></a-box>
        
            <!-- Avant-droite -->
            <a-box position="4.5 0 -2.6" rotation="0 -60 0" width="6.93" height="0.02" depth="0.1" static-body
            material="color: white; emissive: #0035ff ; emissiveIntensity: 0.6"></a-box>
        
            <!-- Arriere-droite -->
            <a-box position="4.5 0 2.6" rotation="0 -120 0" width="6.93" height="0.02" depth="0.1" static-body
            material="color: white; emissive: #0035ff ; emissiveIntensity: 0.6"></a-box>
        
            <!-- Face arriere -->
            <a-box position="0 0 5.2" rotation="0 180 0" width="6.93" height="0.02" depth="0.1" static-body
            material="color: white; emissive: #0035ff ; emissiveIntensity: 0.6"></a-box>
        
            <!-- Arriere-gauche -->
            <a-box position="-4.5 0 2.6" rotation="0 120 0" width="6.93" height="0.02" depth="0.1" static-body
            material="color: white; emissive: #0035ff ; emissiveIntensity: 0.6"></a-box>
        
            <!-- Avant-gauche -->
            <a-box position="-4.5 0 -2.6" rotation="0 60 0" width="6.93" height="0.02" depth="0.1" static-body
            material="color: white; emissive: #0035ff ; emissiveIntensity: 0.6"></a-box>
        </a-entity>    
        
        <!-- Plinthes haut -->
        <a-entity id="plinthes-Haut">
            <!-- Face avant -->
            <a-box position="0 4.75 -5.2" rotation="0 0 0" width="6.93" height="0.02" depth="0.1" static-body
            material="color: white; emissive: #0035ff ; emissiveIntensity: 0.6"></a-box>
        
            <!-- Avant-droite -->
            <a-box position="4.5 4.75 -2.6" rotation="0 -60 0" width="6.93" height="0.02" depth="0.1" static-body
            material="color: white; emissive: #0035ff ; emissiveIntensity: 0.6"></a-box>
        
            <!-- Arriere-droite -->
            <a-box position="4.5 4.75 2.6" rotation="0 -120 0" width="6.93" height="0.02" depth="0.1" static-body
            material="color: white; emissive: #0035ff ; emissiveIntensity: 0.6"></a-box>
        
            <!-- Face arriere -->
            <a-box position="0 4.75 5.2" rotation="0 180 0" width="6.93" height="0.02" depth="0.1" static-body
            material="color: white; emissive: #0035ff ; emissiveIntensity: 0.6"></a-box>
        
            <!-- Arriere-gauche -->
            <a-box position="-4.5 4.75 2.6" rotation="0 120 0" width="6.93" height="0.02" depth="0.1" static-body
            material="color: white; emissive: #0035ff ; emissiveIntensity: 0.6"></a-box>
        
            <!-- Avant-gauche -->
            <a-box position="-4.5 4.75 -2.6" rotation="0 60 0" width="6.93" height="0.02" depth="0.1" static-body
            material="color: white; emissive: #0035ff ; emissiveIntensity: 0.6"></a-box>
        </a-entity>  

        <!-- profondeur terre -->
        <a-entity>
            <a-entity geometry="primitive: cylinder; radius: 2.505; height: 0.01; segmentsRadial: 6"
                id="grass"
                material="color: #0ba133; emissive: #0ba133; emissiveIntensity: 0.3" 
                position="0 1.51 0" rotation="180 30 0" shadow="cast:true; receive:true" static-body="shape: cylinder; cylinderRadius: 2.5; cylinderHeight: 3">
            </a-entity>  
            <a-entity geometry="primitive: cylinder; radius: 2.505; height: 3; segmentsRadial: 6"
                id="water"
                material="color: #692f0b; emissive: #692f0b; emissiveIntensity: 0.3" 
                position="0 0 0" rotation="180 30 0" shadow="cast:true; receive:true" static-body="shape: cylinder; cylinderRadius: 2.5; cylinderHeight: 3">
            </a-entity>  
        </a-entity>
        

        <!-- Nappe phreatique : OBJ sans aframe-extras -->
        <a-assets>
            <a-asset-item id="water-gltf" src="./textures/water_v1.glb"></a-asset-item>
        </a-assets>
        <a-gltf-model 
            src="#water-gltf"
            position="0 0.01 0"
            rotation="0 30 0"
            scale="2.199 1.5 2.199"
            shadow="cast:true; receive:true"
            static-body>
        </a-gltf-model>
        <!-- Panneau de graphique -->
        <a-entity id="chartPanel" position="4.45 2.4 -2.6" rotation="0 -60 0" static-body>
            <a-plane id="chartPlane" width="4" height="3" material="shader: flat; color: white; emissive: white; emissiveIntensity: 1">
            </a-plane>
        </a-entity>

        <!-- Panneau d'information principal -->
        <a-entity id="infoPanel" position="-4.5 2.5 -2.5" rotation="0 60 0" static-body>
            <a-plane width="3.35" height="3.8" color="#333" opacity="0.8">
                <a-text id="infoText" value="Chargement..." 
                        width="2.7" align="left" wrap-count="25"
                        position="-1.3 0 0" color="white"
                        font="./custom-font-a-Frame/custom-a-frame.fnt"></a-text>
            </a-plane>
        </a-entity>

        <!-- Panneau meteo -->
        <a-entity id="meteoPanel" position="4.5 2.5 2.5" rotation="0 -120 0" static-body>
            <a-plane width="2.4" height="3.5" color="#333" opacity="0.8">
                <a-text id="meteoText" value="Chargement meteo..." 
                        width="2.7" align="left" wrap-count="25"
                        position="-1 0 0" color="white"
                        font="./custom-font-a-Frame/custom-a-frame.fnt"></a-text>
            </a-plane>
        </a-entity>

        <!-- Panneau statistiques -->
        <a-entity id="statsPanel" position="-4.39 2.5 2.42" rotation="0 120 0" static-body>
            <a-plane width="2.5" height="3.3" color="#333" opacity="0.8">
                <a-text id="statsText" value="Chargement stats..." 
                        width="2.7" align="left" wrap-count="30"
                        position="-1 0 0" color="white"
                        font="./custom-font-a-Frame/custom-a-frame.fnt"></a-text>
            </a-plane>
        </a-entity>

        <!-- Affichage niveau d'eau -->
        <a-entity id="waterLevelDisplay" position="0 4.5 0" rotation="10 180 0" follow-camera-y>
            <a-plane position="0 -0.1 0.1" rotation="0 0 0" width="2.1" height="0.5"
                material="color: #f5f5f5; opacity: 0.7; emissive: #f5f5f5; emissiveIntensity: 0.3" ></a-plane>
            <a-box width="2.3" height="1" depth="0.1" color="#000000">
                <a-text id="waterLevelText" value="" 
                        width="3" align="center"
                        position="0 -0.1 0.11" color="white"
                        font="./custom-font-a-Frame/custom-a-frame.fnt"></a-text>
            </a-box>
        </a-entity>


        <!-- Camera -->
        <a-entity position="0 1 0" rotation="0 180 0">
            <a-camera raycaster="objects: .interactive" far="12" id="camera" fov="100" 
                look-controls="pointerLockEnabled: true; mouseDrag: true"
                wasd-controls="enabled: true; acceleration: 25" rotation="0 0 0">
                <a-plane id="cursor"
                        position="0 0 -0.1"
                        width="0.006" 
                        height="0.006" 
                        material="src: ./textures/cursor.png; transparent: true; roughness: 100; metalness: 0; emissive: #f5f5f5">
                </a-plane>
            </a-camera>
        </a-entity>

        <!-- Lumiere ambiante-->
        <a-light id="ambiantLight" type="ambient" color="#8899FF" intensity="0.2"></a-light>

        <!-- Ciel -->
        <a-sky color="#ECECEC"></a-sky>
    </a-scene>

<!-- SVG -->
<svg id="topDownView" width="200" height="200"
     style="position: absolute; top: 10px; left: 10px; background: rgba(255,255,255,0.8); z-index: 10; opacity: 0%; pointer-events: none;">
    <polygon id="walls" points="40,0 160,0 215,100 160,200 40,200 -15,100"
             fill="none" stroke="black" stroke-width="2" />
             <polygon id="groundDepth" points="157,100 130,150 75,150 45,100 75,47 125,47"
         fill="rgba(0,0,0,0.2)" stroke="black" stroke-width="2" />
    <circle id="userPoint" cx="100" cy="190" r="5" fill="red" />
    
    <!-- Ajout des rectangles pour les portes -->
    <rect id="backDoorRect" x="82" y="0" width="35" height="3" fill="green" />
    <rect id="frontDoorRect" x="82" y="198" width="35" height="3" fill="blue" />
</svg>

<script>
    const config = {
        scaleFactor: 20,
        svgCenter: { x: 100, y: 100 },
        wallPolygon: [
            [40, 0], // Haut gauche
            [160, 0], // Haut droit
            [215, 100], // Millieu droit
            [160, 200], // Bas Droit
            [40, 200], // Bas gauche
            [-15, 100] // Millieu gauche
        ],
        groundDepthPolygon: [
            [155,100], // Milieu droit
            [130,147], // Droite bas
            [75,147], // Gauche bas
            [46 ,100], // Millieu Gauche
            [72,52], // Haut gauche
            [127,52] // Haut droite
        ]
    };

    let lastValidCameraPosition = null;

    function isInsidePolygon(x, y, polygon) {
        let inside = false;
        for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
            const xi = polygon[i][0], yi = polygon[i][1];
            const xj = polygon[j][0], yj = polygon[j][1];
            const intersect = ((yi > y) !== (yj > y)) &&
                (x < (xj - xi) * (y - yi) / ((yj - yi) || 0.00001) + xi);
            if (intersect) inside = !inside;
        }
        return inside;
    }

    function updateSVGPoint(camera, userPoint) {
        const position = camera.getAttribute('position');
        const svgX = config.svgCenter.x + position.x * config.scaleFactor;
        const svgY = config.svgCenter.y - position.z * config.scaleFactor;

        if (isInsidePolygon(svgX, svgY, config.wallPolygon) &&
            !isInsidePolygon(svgX, svgY, config.groundDepthPolygon)) {
            userPoint.setAttribute('cx', svgX);
            userPoint.setAttribute('cy', svgY);
            lastValidCameraPosition = { ...position };
        } else if (lastValidCameraPosition) {
            // R√©tablir la position pr√©c√©dente valide
            camera.setAttribute('position', {
                x: lastValidCameraPosition.x,
                y: position.y,
                z: lastValidCameraPosition.z
            });
        }
    }

    AFRAME.registerComponent('sync-svg-position', {
        tick: function () {
            const camera = this.el;
            const userPoint = document.getElementById('userPoint');
            updateSVGPoint(camera, userPoint);
        }
    });

    window.addEventListener('load', () => {
        const camera = document.querySelector('#camera');
        const userPoint = document.getElementById('userPoint');

        if (!camera) {
            console.error("Cam√©ra introuvable !");
            return;
        }

        camera.setAttribute('position', { x: 0, y: 1, z: 4.5 });
        lastValidCameraPosition = { x: 0, y: 1, z: -4.5 };
        camera.setAttribute('sync-svg-position', '');

        // Mise √† jour initiale
        setTimeout(() => {
            updateSVGPoint(camera, userPoint);
        }, 100);
    });

    // Suivi clavier
    document.addEventListener('keydown', (event) => {
        if (['z', 'q', 's', 'd'].includes(event.key.toLowerCase())) {
            const camera = document.querySelector('#camera');
            const userPoint = document.getElementById('userPoint');
            updateSVGPoint(camera, userPoint);
        }
    });

    // Suivi position en dehors du tick (ex: drag)
    document.addEventListener('DOMContentLoaded', () => {
        const camera = document.querySelector('#camera');
        const userPoint = document.getElementById('userPoint');
        camera.addEventListener('componentchanged', (event) => {
            if (event.detail.name === 'position') {
                updateSVGPoint(camera, userPoint);
            }
        });
    });

    // R√©cup√©ration des donn√©es depuis le sessionStorage
    const stationData = JSON.parse(sessionStorage.getItem('waterData'));
    const apiBaseUrl = "https://hubeau.eaufrance.fr/api/v1/niveaux_nappes";
    
    // Objet pour stocker toutes les donn√©es
    const waterData = {
        stationInfo: stationData.stationInfo,
        waterLevels: [],
        lastMeasurement: null,
        meteoData: null,
        statistics: null
    };

    let stations = [];
    let currentStationIndex = 0;

    // Fonction pour convertir le format de date DD-MM-YYYY en YYYY-MM-DD
    function convertToAPIDateFormat(dateStr) {
        const [day, month, year] = dateStr.split('-');
        return `${year}-${month}-${day}`;
    }

    // Fonction pour formater le texte avec saut de ligne
    function formatText(content) {
        return content.replace(/<br>/g, '\n');
    }

    // Fonction utilitaire pour fetch avec retry
    async function fetchWithRetry(url, options = {}, maxAttempts = 2) {
        let lastError;
        for (let attempt = 1; attempt <= maxAttempts; attempt++) {
            try {
                const response = await fetch(url, options);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                return await response.json();
            } catch (err) {
                lastError = err;
                if (attempt === maxAttempts) {
                    console.error(`Erreur lors de l'appel API (${url}) apr√®s ${maxAttempts} tentatives :`, err);
                }
            }
        }
        return null;
    }

    // Fonction utilitaire pour fetch avec retry et gestion du 429 (Too Many Requests)
    async function fetchWithRetry(url, options = {}, maxAttempts = 2, delayMs = 1000) {
        let lastError;
        for (let attempt = 1; attempt <= maxAttempts; attempt++) {
            try {
                const response = await fetch(url, options);
                if (response.status === 429) {
                    // Trop de requ√™tes, attendre avant de r√©essayer
                    if (attempt < maxAttempts) {
                        console.warn(`API 429 Too Many Requests, tentative ${attempt}/${maxAttempts}, attente ${delayMs}ms...`);
                        await new Promise(res => setTimeout(res, delayMs));
                        continue;
                    } else {
                        throw new Error("Erreur 429: Trop de requ√™tes (Too Many Requests)");
                    }
                }
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                return await response.json();
            } catch (err) {
                lastError = err;
                if (attempt === maxAttempts) {
                    console.error(`Erreur lors de l'appel API (${url}) apr√®s ${maxAttempts} tentatives :`, err);
                }
            }
        }
        return null;
    }

    // Fonction pour r√©cup√©rer les donn√©es de niveau d'eau
    async function fetchWaterLevels() {
        try {
            const dateDebutAPI = convertToAPIDateFormat(waterData.stationInfo.dateDebut);
            const dateFinAPI = convertToAPIDateFormat(waterData.stationInfo.dateFin);
            const url = `${apiBaseUrl}/chroniques?code_bss=${waterData.stationInfo.codeBss}&date_debut_mesure=${dateDebutAPI}&date_fin_mesure=${dateFinAPI}`;
            const data = await fetchWithRetry(url);
            if (data && data.data && data.data.length > 0) {
                waterData.waterLevels = data.data.map(item => ({
                    value: item.niveau_nappe_eau,
                    date: new Date(item.date_mesure).toLocaleDateString(),
                    profondeur: item.profondeur_nappe
                }));
                waterData.lastMeasurement = waterData.waterLevels[waterData.waterLevels.length - 1];
                calculateStatistics();
            }
        } catch (error) {
            console.error("Erreur lors de la r√©cup√©ration des niveaux d'eau:", error);
        }
    }

    // Fonction pour r√©cup√©rer les donn√©es m√©t√©o
    async function fetchMeteoData() {
        try {
            const { lat, lng } = waterData.stationInfo.coordinates;
            const dateDebutAPI = convertToAPIDateFormat(waterData.stationInfo.dateDebut);
            const dateFinAPI = convertToAPIDateFormat(waterData.stationInfo.dateFin);
            const url = `https://archive-api.open-meteo.com/v1/archive?latitude=${lat}&longitude=${lng}&start_date=${dateDebutAPI}&end_date=${dateFinAPI}&daily=temperature_2m_max,temperature_2m_min,precipitation_sum,weather_code`;
            const data = await fetchWithRetry(url, {}, 2, 2000); // 2 tentatives, 2s d'attente si 429
            if (data && data.daily) {
                waterData.meteoData = {
                    tempMax: data.daily.temperature_2m_max,
                    tempMin: data.daily.temperature_2m_min,
                    precipitation: data.daily.precipitation_sum,
                    weatherCode: data.daily.weather_code,
                    dates: data.daily.time.map(date => new Date(date).toLocaleDateString())
                };
            }
        } catch (error) {
            console.error("Erreur lors de la r√©cup√©ration des donn√©es m√©t√©o:", error);
        }
    }

    // Fonction pour calculer les statistiques
    function calculateStatistics() {
        const values = waterData.waterLevels.map(item => item.value).sort((a, b) => a - b);
        const n = values.length;
        
        if (n > 0) {
            waterData.statistics = {
                current: {
                    median: calculatePercentile(values, 50),
                    q1: calculatePercentile(values, 25),
                    q3: calculatePercentile(values, 75),
                    min: values[0],
                    max: values[values.length - 1]
                }
            };
        }
    }

    function calculatePercentile(values, percentile) {
        const index = (percentile / 100) * (values.length - 1);
        if (Math.floor(index) === index) {
            return values[index];
        }
        const i = Math.floor(index);
        const fraction = index - i;
        return values[i] + (values[i + 1] - values[i]) * fraction;
    }

    // Fonction pour interpoler les couleurs dynamiquement sur un spectre plus sombre
    function interpolateColor(value, min, max) {
        const percentage = Math.min(Math.max((value - min) / (max - min), 0), 1); 
        const hue = (1 - percentage) * 240; // 240¬∞ (bleu) ‚Üí 0¬∞ (rouge) sur le cercle chromatique
        return `hsl(${hue}, 100%, 37%)`; // R√©duit la luminosit√© √† 30% pour des couleurs plus sombres
    }

    // Mise √† jour des panneaux 3D
    function updatePanels() {
        // Panneau principal
        const infoContent = `
            ${waterData.stationInfo.commune}<br>
            D√©partement: ${waterData.stationInfo.departement}<br>
            Code BSS: ${waterData.stationInfo.codeBss}<br>
            Altitude: ${waterData.stationInfo.altitude} m<br>
            Profondeur Investigation: ${waterData.stationInfo.profondeurInv} m<br>
            ${waterData.lastMeasurement ? `Profondeur actuelle: ${waterData.lastMeasurement.profondeur.toFixed(2)} m<br>` : ''}
            P√©riode: ${waterData.stationInfo.dateDebut} au ${waterData.stationInfo.dateFin}
        `;
        document.querySelector('#infoText').setAttribute('value', formatText(infoContent));

        // Panneau meteo
        if (waterData.meteoData) {
            const avgTempMax = (waterData.meteoData.tempMax.reduce((a, b) => a + b, 0) / waterData.meteoData.tempMax.length).toFixed(1);
            const avgTempMin = (waterData.meteoData.tempMin.reduce((a, b) => a + b, 0) / waterData.meteoData.tempMin.length).toFixed(1);
            const totalPrecip = waterData.meteoData.precipitation.reduce((a, b) => a + b, 0).toFixed(1);
            
            const meteoContent = `
                Donn√©es m√©t√©o<br>
                (Moyenne sur la p√©riode)<br>
                Temp. max: ${avgTempMax}¬∞C<br>
                Temp. min: ${avgTempMin}¬∞C<br>
                Pr√©cipitations: ${totalPrecip} mm<br>
                P√©riode: ${waterData.meteoData.dates[0]}<br>
                √† ${waterData.meteoData.dates[waterData.meteoData.dates.length-1]}
            `;
            document.querySelector('#meteoText').setAttribute('value', formatText(meteoContent));

            // D√©finie la couleur des plinthes et de la lumi√®re en fonction de la temp√©rature
            let plinthColor, ambientColor;
            const tempRangeMin = 5;
            const tempRangeMax = 28;

            // Interpolation des couleurs en fonction de la temp√©rature moyenne
            const avgTemp = (parseFloat(avgTempMax) + parseFloat(avgTempMin)) / 2; // Assure que les valeurs sont des nombres
            plinthColor = interpolateColor(avgTempMax, tempRangeMin, tempRangeMax);
            ambientColor = plinthColor;

            // Met les plinthes √† la couleur correspondante
            document.querySelectorAll('#plinthes-Bas a-box, #plinthes-Haut a-box').forEach(plinth => {
                plinth.setAttribute('material', `color: ${plinthColor}; emissive: ${plinthColor}; emissiveIntensity: 0.3`); // R√©duit l'intensit√© de l'√©missivit√©
            });

            // Met √† jour la texture des murs en fonction de la couleur interpol√©e
            document.querySelectorAll('#mur a-plane').forEach(wall => {
                let textureSrc;
                const hue = parseInt(plinthColor.match(/\d+/)[0]);
                if (hue >= 180) { // Bleu
                    textureSrc = './textures/texture-mur.jpg';
                } else if (hue >= 90) { // Vert
                    textureSrc = './textures/texture-mur-vert.jpg';
                } else if (hue >= 30) { // Orange
                    textureSrc = './textures/texture-mur-orange.jpg';
                } else { // Rouge
                    textureSrc = './textures/texture-mur-rouge.jpg';
                }
                wall.setAttribute('material', `src: ${textureSrc}; roughness: 1; metalness: 0; repeat: 3 1`);
            });

            // Met √† jour la lumi√®re ambiante
            document.querySelector('#ambiantLight').setAttribute('color', ambientColor);
        }

        // Panneau stats
        if (waterData.statistics) {
            const statsContent = `
                Statistiques du niveau d'eau<br>
                P√©riode: ${waterData.stationInfo.dateDebut}<br>
                au ${waterData.stationInfo.dateFin}<br>
                M√©diane: ${waterData.statistics.current.median.toFixed(2)} m<br>
                Quartile 1: ${waterData.statistics.current.q1.toFixed(2)} m<br>
                Quartile 3: ${waterData.statistics.current.q3.toFixed(2)} m<br>
                Minimum: ${waterData.statistics.current.min.toFixed(2)} m<br>
                Maximum: ${waterData.statistics.current.max.toFixed(2)} m
            `;
            document.querySelector('#statsText').setAttribute('value', formatText(statsContent));
        }
    }

    function setupWater() {
        const waterElement = document.querySelector('#water');
        if (!waterData.lastMeasurement) return;

        const values = waterData.waterLevels.map(item => item.value);
        const minValue = waterData.statistics.current.min;
        const maxValue = waterData.statistics.current.max;
        
        const waterLevelContent = `Niveau: ${waterData.lastMeasurement.value.toFixed(2)} m\n(Min: ${minValue.toFixed(2)} m / Max: ${maxValue.toFixed(2)} m)`;
        document.querySelector('#waterLevelText').setAttribute('value', waterLevelContent);

        const maxDepthVisual = 3;
        const scaledHeight = (waterData.lastMeasurement.profondeur / waterData.stationInfo.altitude) * maxDepthVisual;
        const waterY = (1.5 + 0.01) - scaledHeight / 2;

        waterElement.setAttribute('geometry', {
            primitive: 'cylinder',
            radius: 2.505,
            height: scaledHeight,
            segmentsRadial: 6
        });

        waterElement.setAttribute('position', `0 ${waterY} 0`);
    }

    async function createChart() {
        const canvas = document.createElement('canvas');
        canvas.width = 800;
        canvas.height = 600;
        const ctx = canvas.getContext('2d');

        const labels = waterData.waterLevels.map(item => item.date);
        const chartValues = waterData.waterLevels.map(item => item.value);

        const chart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [{
                    label: 'Niveau de la nappe (m)',
                    data: chartValues,
                    backgroundColor: 'rgba(54, 162, 235, 0.2)',
                    borderColor: 'rgba(54, 162, 235, 1)',
                    borderWidth: 2,
                    tension: 0.1,
                    fill: true
                }]
            },
            options: {
                animation: {
                    onComplete: () => {
                        const chartImgDataUrl = canvas.toDataURL("image/png");
                        const chartPlane = document.querySelector('#chartPlane');
                        chartPlane.setAttribute('material', 'src', chartImgDataUrl);
                    }
                },
                responsive: false,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: `√âvolution du niveau d'eau - ${waterData.stationInfo.commune} (${waterData.stationInfo.dateDebut} au ${waterData.stationInfo.dateFin})`
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return `Niveau: ${context.parsed.y.toFixed(2)} m`;
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: false,
                        title: {
                            display: true,
                            text: 'Niveau (m)'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: 'Date'
                        }
                    }
                }
            }
        });
    }

    async function fetchStations(regionCode, dateDebut, dateFin, selectedCityCodeBss) {
        try {
            // R√©cup√©rer toutes les villes de la r√©gion avec des donn√©es disponibles
            const response = await fetch(`${apiBaseUrl}?code_departement=${regionCode}&date_debut_mesure=${dateDebut}&date_fin_mesure=${dateFin}`);
            const data = await response.json();

            // Mapper les stations avec les d√©tails n√©cessaires
            stations = data.data.map(station => ({
                codeBss: station.code_bss,
                longitude: station.longitude,
                latitude: station.latitude,
                commune: station.commune,
                departement: station.departement,
                altitude: station.altitude,
                profondeurInv: station.profondeur_investigation
            }));

            // Trier les stations par proximit√©, en commen√ßant par la ville s√©lectionn√©e
            stations = sortStationsByProximity(stations, selectedCityCodeBss);

            // Ajouter les stations tri√©es dans waterData
            waterData.sortedStations = stations;
        } catch (error) {
            console.error("Erreur lors de la r√©cup√©ration des stations:", error);
        }
    }

    function sortStationsByProximity(stations, selectedCityCodeBss) {
        const distanceMatrix = createDistanceMatrix(stations);
        const visited = new Set();
        const sorted = [];

        // Trouver l'index de la ville s√©lectionn√©e
        const startIndex = stations.findIndex(station => station.codeBss === selectedCityCodeBss);
        if (startIndex === -1) {
            throw new Error("La ville s√©lectionn√©e n'a pas √©t√© trouv√©e dans les donn√©es.");
        }

        let currentIndex = startIndex;
        visited.add(currentIndex);
        sorted.push(stations[currentIndex]);

        while (visited.size < stations.length) {
            let closestIndex = -1;
            let minDist = Infinity;

            // Trouver la station la plus proche
            for (let i = 0; i < stations.length; i++) {
                if (visited.has(i)) continue;

                const dist = distanceMatrix[currentIndex][i];
                if (dist < minDist) {
                    minDist = dist;
                    closestIndex = i;
                }
            }

            if (closestIndex !== -1) {
                visited.add(closestIndex);
                sorted.push(stations[closestIndex]);
                currentIndex = closestIndex;
            }
        }

        return sorted;
    }

    function createDistanceMatrix(stations) {
        // Cr√©er une matrice de distances entre les stations
        return stations.map(s1 =>
            stations.map(s2 =>
                s1 === s2 ? 0 : euclideanDistance(s1.longitude, s1.latitude, s2.longitude, s2.latitude)
            )
        );
    }

    function euclideanDistance(lon1, lat1, lon2, lat2) {
        // Calculer la distance euclidienne entre deux coordonn√©es
        const dx = lon1 - lon2;
        const dy = lat1 - lat2;
        return dx * dx + dy * dy;
    }

    // Fonction pour calculer la distance euclidienne
    function calculateDistance(lat1, lon1, lat2, lon2) {
        const dx = lon1 - lon2;
        const dy = lat1 - lat2;
        return Math.sqrt(dx * dx + dy * dy);
    }

    // Fonction pour trier les stations par proximit√© √† la station courante
    function sortStationsByProximity(infoPourAlgo, selectedBss) {
        const selectedStation = infoPourAlgo.find(st => st.BSS === selectedBss);
        if (!selectedStation) return infoPourAlgo;
        return infoPourAlgo
            .map(st => ({
                ...st,
                distance: calculateDistance(selectedStation.latitude, selectedStation.longitude, st.latitude, st.longitude)
            }))
            .sort((a, b) => a.distance - b.distance);
    }

    // Fonction pour charger les donn√©es d'une station par code BSS
    async function loadStationDataByBss(codeBss) {
        const stationInfo = stations.find(st => st.BSS === codeBss);
        if (!stationInfo) return;

        // Mettre √† jour stationInfo dans waterData
        waterData.stationInfo.codeBss = stationInfo.BSS;
        waterData.stationInfo.coordinates = { lat: stationInfo.latitude, lng: stationInfo.longitude };
        if (stationInfo.commune) waterData.stationInfo.commune = stationInfo.commune;
        if (stationInfo.departement) waterData.stationInfo.departement = stationInfo.departement;
        if (stationInfo.altitude) waterData.stationInfo.altitude = stationInfo.altitude;
        if (stationInfo.profondeurInv) waterData.stationInfo.profondeurInv = stationInfo.profondeurInv;

        // Reset data before fetching
        waterData.waterLevels = [];
        waterData.lastMeasurement = null;
        waterData.meteoData = null;
        waterData.statistics = null;

        // R√©cup√©rer les donn√©es
        await fetchWaterLevels();
        await fetchMeteoData();
        calculateStatistics();

        // Mettre √† jour les panneaux et l'eau
        updatePanels();
        setupWater();
        createChart();

        // Stocker TOUTES les donn√©es √† jour dans le sessionStorage (apr√®s update)
        sessionStorage.setItem('waterData', JSON.stringify({
            ...waterData,
            infoPourAlgo: stations
        }));

        // R√©initialiser la position de la cam√©ra √† la position initiale
        const camera = document.querySelector('#camera');
        if (camera) {
            camera.setAttribute('position', { x: 0, y: 1, z: 4.5 });
            camera.setAttribute('rotation', { x: 0, y: 180, z: 0 });
        }
    }

    // Pour √©viter les changements multiples, on bloque la transition tant qu'un chargement est en cours
    let isTransitioning = false;

    function handleDoorTransition(isBackDoor) {
        if (isTransitioning) return;
        isTransitioning = true;

        // Cr√©er l'overlay noir sans texte
        const fadeOverlay = document.createElement('div');
        fadeOverlay.style.position = 'absolute';
        fadeOverlay.style.top = '0';
        fadeOverlay.style.left = '0';
        fadeOverlay.style.width = '100%';
        fadeOverlay.style.height = '100%';
        fadeOverlay.style.backgroundColor = 'black';
        fadeOverlay.style.opacity = '0';
        fadeOverlay.style.transition = 'opacity 0.5s';
        fadeOverlay.style.zIndex = '9999';
        document.body.appendChild(fadeOverlay);

        // Bloquer les d√©placements
        const camera = document.querySelector('#camera');
        if (camera) {
            camera.setAttribute('wasd-controls', 'enabled: false; acceleration: 0');
        }

        fadeOverlay.style.opacity = '1';
        setTimeout(async () => {
            const prevIndex = currentStationIndex;
            if (isBackDoor) {
                currentStationIndex = (currentStationIndex === 0) ? stations.length - 1 : currentStationIndex - 1;
            } else {
                currentStationIndex = (currentStationIndex === stations.length - 1) ? 0 : currentStationIndex + 1;
            }
            const nextIndex = currentStationIndex;
            const nextStation = stations[currentStationIndex];
            // Enregistrer l'index courant dans le localStorage pour persistance
            localStorage.setItem('currentStationIndex', currentStationIndex);
            console.log(`Changement de ville : index actuel = ${prevIndex}, prochain index = ${nextIndex}`);
            await loadStationDataByBss(nextStation.BSS);

            // D√©bloquer les d√©placements (remettre la valeur par d√©faut)
            if (camera) {
                camera.setAttribute('wasd-controls', 'enabled: true; acceleration: 25');
            }

            fadeOverlay.style.opacity = '0';
            setTimeout(() => {
                document.body.removeChild(fadeOverlay);
                isTransitioning = false;
            }, 500);
        }, 500);
    }

    function checkDoorCollision(cameraPosition) {
        const svgX = config.svgCenter.x + cameraPosition.x * config.scaleFactor;
        const svgY = config.svgCenter.y - cameraPosition.z * config.scaleFactor;

        const backDoorRect = { x: 82, y: 0, width: 20, height: 3 }; 
        const frontDoorRect = { x: 82, y: 198, width: 20, height: 3 };

        if (svgX >= backDoorRect.x && svgX <= backDoorRect.x + backDoorRect.width &&
            svgY >= backDoorRect.y && svgY <= backDoorRect.y + backDoorRect.height) {
            handleDoorTransition(true);
        } else if (svgX >= frontDoorRect.x && svgX <= frontDoorRect.x + frontDoorRect.width &&
                   svgY >= frontDoorRect.y && svgY <= frontDoorRect.y + frontDoorRect.height) {
            handleDoorTransition(false);
        }
    }

    AFRAME.registerComponent('check-doors', {
        tick: function () {
            const camera = this.el;
            const position = camera.getAttribute('position');
            checkDoorCollision(position);
        }
    });

    document.addEventListener('DOMContentLoaded', async function () {
        // Utiliser infoPourAlgo pour la navigation
        const infoPourAlgo = stationData.infoPourAlgo;
        const selectedBss = stationData.stationInfo.codeBss;

        // Ajout : stocker toutes les infos n√©cessaires pour chaque station (commune, altitude, stats, etc.)
        stations = infoPourAlgo.map(st => ({
            BSS: st.BSS,
            longitude: st.longitude,
            latitude: st.latitude,
            commune: st.commune,
            departement: st.departement,
            altitude: st.altitude,
            profondeurInv: st.profondeurInv,
            statistics: st.statistics // {median, q1, q3, min, max}
        }));

        // Supprimer les doublons √©ventuels (par BSS)
        stations = stations.filter((st, idx, arr) =>
            arr.findIndex(s2 => s2.BSS === st.BSS) === idx
        );

        stations = sortStationsByProximity(stations, selectedBss);

        // Toujours d√©marrer √† l'index 0 apr√®s un rafra√Æchissement
        currentStationIndex = 0;

        await loadStationDataByBss(stations[currentStationIndex].BSS);

        // Activer la d√©tection des portes
        const camera = document.querySelector('#camera');
        camera.setAttribute('check-doors', '');
    });
</script>

    <!-- Bouton menu lat√©ral -->
    <button id="openMapMenuBtn" style="position:fixed; left:10px; top:50%; transform:translateY(-50%); z-index:10001; background:white; color:black; border:none; border-radius:5px; padding:8px 6px; font-size:1.5em; cursor:pointer;">
        üó∫Ô∏è (k)
    </button>

    <!-- Overlay menu lat√©ral (initialement cach√©) -->
    <div id="mapMenuOverlay" style="position:fixed; left:0; top:0; width:100vw; height:100vh; background:black; z-index:10000; display:none; flex-direction:column; align-items:center; justify-content:center; overflow:hidden;">
        <div id="closeMapMenuBtn" style="position:absolute; top:20px; left:20px; color:white; font-size:2em; cursor:pointer; z-index:10001;">‚úï</div>
        <div style="position:absolute; top:20px; right:40px; z-index:10002;">
            <button id="showScatterBtn" style="padding:8px 18px; font-size:1em; background:#2196f3; color:white; border:none; border-radius:6px; cursor:pointer;">Nuage de points</button>
            <button id="backToMapBtn" style="padding:8px 18px; font-size:1em; background:#333; color:white; border:none; border-radius:6px; cursor:pointer; display:none;">Retour carte</button>
        </div>
        <div id="leafletMapContainer" style="width:80vw; height:80vh; margin:auto; border-radius:16px; overflow:hidden; box-shadow:0 0 40px #000;"></div>
        <div id="scatterChartContainer" style="width:80vw; height:80vh; margin:auto; border-radius:16px; overflow:hidden; box-shadow:0 0 40px #000; background:white; display:none; align-items:center; justify-content:center;">
            <canvas id="scatterChart"></canvas>
        </div>
    </div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

<script>
    // Couleurs pour la map et A-Frame
    const COLOR_CURRENT = '#ffeb3b'; // jaune pour la ville actuelle
    const COLOR_NEXT = '#1976d2';    // bleu (A-Frame)
    const COLOR_PREV = '#14532d';    // vert fonc√© (A-Frame)

    // ----------- MENU CARTE LEAFLET -----------
    let leafletMap, cityMarkers = [], selectedMapCityIndex = null;

    // Animation d'ouverture/fermeture du menu
    function openMapMenu() {
        const overlay = document.getElementById('mapMenuOverlay');
        overlay.style.display = 'flex';
        overlay.style.opacity = 0;
        overlay.style.transition = 'opacity 0.4s';
        setTimeout(() => { overlay.style.opacity = 1; }, 10);

        // D√©sactiver le pointer lock et afficher le curseur natif
        const aframeCanvas = document.querySelector('a-scene').canvas;
        if (aframeCanvas && document.exitPointerLock) {
            document.exitPointerLock();
        }
        document.body.style.cursor = 'auto';

        // Initialiser la carte Leaflet si pas d√©j√† fait
        if (!leafletMap) {
            leafletMap = L.map('leafletMapContainer', {
                zoomControl: true,
                attributionControl: false
            }).setView([stations[0].latitude, stations[0].longitude], 9);

            // Fond de carte
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 18,
                minZoom: 5
            }).addTo(leafletMap);

            // Ajout des marqueurs pour chaque ville
            cityMarkers = [];
            stations.forEach((st, idx) => {
                // V√©rifier que les coordonn√©es sont valides
                if (
                    typeof st.latitude === 'number' && !isNaN(st.latitude) &&
                    typeof st.longitude === 'number' && !isNaN(st.longitude)
                ) {
                    const markerIcon = L.divIcon({
                        className: '',
                        html: getMarkerHtml(idx),
                        iconSize: [18,18],
                        iconAnchor: [9,9]
                    });
                    const marker = L.marker([st.latitude, st.longitude], {icon: markerIcon}).addTo(leafletMap);

                    marker.on('click', () => {
                        selectMapCity(idx);
                    });

                    cityMarkers.push(marker);
                }
            });
        } else {
            // Mettre √† jour les couleurs des marqueurs
            cityMarkers.forEach((marker, idx) => {
                marker.setIcon(L.divIcon({
                    className: '',
                    html: getMarkerHtml(idx),
                    iconSize: [18,18],
                    iconAnchor: [9,9]
                }));
            });
            leafletMap.setView([stations[currentStationIndex].latitude, stations[currentStationIndex].longitude], leafletMap.getZoom());
        }

        // R√©initialiser panneau info
        document.getElementById('cityInfoPanel').style.display = 'none';
        document.getElementById('teleportBtn').style.display = 'none';
        selectedMapCityIndex = null;
    }

    function closeMapMenu() {
        const overlay = document.getElementById('mapMenuOverlay');
        overlay.style.opacity = 0;
        setTimeout(() => { overlay.style.display = 'none'; }, 400);

        // R√©activer le pointer lock et masquer le curseur natif
        const aframeCanvas = document.querySelector('a-scene').canvas;
        if (aframeCanvas && aframeCanvas.requestPointerLock) {
            aframeCanvas.requestPointerLock();
        }
        document.body.style.cursor = 'none';
    }

    // S√©lection d'une ville sur la carte
    function selectMapCity(idx) {
        selectedMapCityIndex = idx;
        const city = stations[idx];
        // Afficher un popup au-dessus du marqueur avec bouton t√©l√©portation si ce n'est pas la ville courante
        let popupHtml = `<div style="font-size:1.1em; font-weight:bold;">${city.commune || city.BSS}</div>`;
        if (idx !== currentStationIndex) {
            popupHtml += `<br><button id="popupTeleportBtn" style="margin-top:8px; padding:6px 14px; font-size:1em; background:#e53935; color:white; border:none; border-radius:6px; cursor:pointer;">T√©l√©porter ici</button>`;
        }
        cityMarkers[idx].bindPopup(popupHtml, { closeButton: true, className: 'custom-popup' }).openPopup();

        // Attacher l'√©v√©nement au bouton apr√®s affichage du popup
        setTimeout(() => {
            const btn = document.getElementById('popupTeleportBtn');
            if (btn) {
                btn.onclick = async function() {
                    await teleportToSelectedCity();
                };
            }
        }, 0);
    }

    // T√©l√©portation vers la ville s√©lectionn√©e
    async function teleportToSelectedCity() {
        if (selectedMapCityIndex == null || selectedMapCityIndex === currentStationIndex) return;

        // R√©ordonner le tableau pour que la ville s√©lectionn√©e soit √† l'index 0
        if (selectedMapCityIndex !== 0) {
            const selectedCity = stations[selectedMapCityIndex];
            stations.splice(selectedMapCityIndex, 1);
            stations.unshift(selectedCity);
            currentStationIndex = 0;
        } else {
            currentStationIndex = 0;
        }

        // Mettre √† jour la carte (curseur rouge, bleu, vert)
        cityMarkers.forEach((marker, idx) => {
            marker.setIcon(L.divIcon({
                className: '',
                html: getMarkerHtml(idx),
                iconSize: [18,18],
                iconAnchor: [9,9]
            }));
        });

        // Charger la ville dans A-Frame
        await loadStationDataByBss(stations[0].BSS);

        // Fermer le menu
        closeMapMenu();
    }

    // Fonction utilitaire pour couleur des marqueurs
    function getMarkerHtml(idx) {
        // Calculer index pr√©c√©dent et suivant (circular)
        const prevIdx = (currentStationIndex === 0) ? stations.length - 1 : currentStationIndex - 1;
        const nextIdx = (currentStationIndex === stations.length - 1) ? 0 : currentStationIndex + 1;
        let color = '#2196f3'; // d√©faut

        if (idx === currentStationIndex) color = COLOR_CURRENT;
        else if (idx === nextIdx) color = COLOR_NEXT;
        else if (idx === prevIdx) color = COLOR_PREV;

        return `<div style="width:18px;height:18px;border-radius:50%;background:${color};border:2px solid white;box-shadow:0 0 6px #000"></div>`;
    }

    // Gestion des boutons menu
    document.addEventListener('DOMContentLoaded', function () {
        document.getElementById('openMapMenuBtn').onclick = openMapMenu;
        document.getElementById('closeMapMenuBtn').onclick = closeMapMenu;
        document.getElementById('showScatterBtn').onclick = showScatterChart;
        document.getElementById('backToMapBtn').onclick = hideScatterChart;
    });

    // Ajout : ouverture de la carte avec la touche 'k'
    document.addEventListener('keydown', function (event) {
        if (event.key.toLowerCase() === 'k') {
            openMapMenu();
        }
    });

    // Masquer le curseur natif par d√©faut (sauf quand la carte est ouverte)
    document.body.style.cursor = 'none';
</script>
</body>
</html>